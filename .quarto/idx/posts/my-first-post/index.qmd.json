{"title":"How AI Generates Images: A Simple Explanation","markdown":{"yaml":{"title":"How AI Generates Images: A Simple Explanation","author":"Devon Vorster","date":"2026-01-15","date-modified":"2026-01-15","categories":["news","code","analysis"],"image":"image.jpg"},"headingText":"A simple explanation of image-generating AI models: Diffusion Models and the Game of Telephone","containsRefs":false,"markdown":"\n\n\n\n\nWith the popularity and advancement of AI rapidly accelerating, artificial intelligence has become a part of daily life for many people. In particular, advances in image-generating AI models have been an especially exciting area. Diffusion models, named after the physical process they are inspired by, are currently the most widely used and successful tools for generating images with AI.\nDiffusion models are complex, but in this post I will attempt to break them down in a more manageable way to help explain how they work. At a high level, diffusion models can be divided into two stages: a forward stage and a backward stage. Surprisingly, these processes can be explained quite simply by likening them to a game of telephone.\n\n## Moving Forwards\n\nFor anyone who has never played, telephone starts when one person whispers a phrase or sentence into another person’s ear. That phrase is then passed to the next person, and the next, until it reaches the last person in line. The goal of the game is to keep the phrase as close to the original as possible. Inevitably, as the phrase moves down the line, people make mistakes and it gets morphed into something completely different, often nonsensical. This is what makes the game enjoyable — you never really know what will happen at the end. For example, the phrase “a cat jumps over the moon and runs across the stars” might end up as “the cat’s stars are jumps and the moon is over.”\n\n![Figure 1: A game of telephone where carrot turns into elephant ducks and a bicycle. Generated by Google Gemini (Nano Banana version), January 16, 2026](telephone.png)\n\nA diffusion model works in a somewhat similar way. We start with an image and iteratively add random noise — small random changes to the pixels — until the image becomes pure static, like the static on a TV. This noise plays a role similar to the changes that happen as a phrase moves from person to person in the game of telephone. Each step makes the image a little stranger, until eventually it is no longer recognizable at all. Unlike in the game, however, these changes are not caused by misunderstanding; they are deliberately added randomness.\n\n\n\n## Learning to Go Backwards\n\nSo why would we want to destroy an image like this?\nLet’s return to our telephone analogy. Imagine playing a billion games of telephone, and for each game there is a single observer. This observer is not part of the game, but they can hear the phrase at every step as it moves down the line. Over time, they become very good at understanding the kinds of changes that typically happen from one step to the next. Eventually, they learn how to predict what the phrase likely sounded like before the most recent change.\n\n![Figure 2: Diffusion process.](diffusion.png)\n\nIf we now give this observer the final, altered phrase, they could work backwards step by step, predicting how to undo each change until they reach something very close to the original sentence. Importantly, the observer does not know the previous phrases. The best they can do is make incremental predictions about what likely versions of the earlier stages might have been. If they make good predictions, they may get close to the original phrase.\nThis is essentially how diffusion models work as well. During training, the model learns similar patterns — specifically, how to predict the noise that was added at each step of the process. Then, when generating an image, the model starts from pure noise and repeatedly removes small amounts of it. Step by step, random static turns into structure, and structure turns into an image.\n\nWhen you enter a prompt into an image generator — “an orange cat,” for example — the model begins with static and gradually works backwards, predicting how to remove noise a little bit at a time in a way that results in something resembling an orange cat. Just like the observer, the model doesn’t actually know the previous stages. It only sees the static. The best it can do is make predictions about what likely versions of those earlier stages might have been, based on its learned patterns and the description “an orange cat” (more on this later). This is why AI-generated images are sometimes not quite right: the model cannot always return to something that perfectly resembles an actual orange cat, just as the observer cannot always recover the original phrase.\n\n## Text Embeddings\nThat explanation raises another question: how does the model know how to make a cat when asked for a cat, and a dog when asked for a dog?\n\nThe answer lies in something called text embeddings.\n\nDuring training, each image is paired with a text description, such as an image of an orange cat labeled “an orange cat.”This text is converted into a text embedding — a numerical representation of the meaning of the description that can be passed to the model. The image and its text embedding are then processed together.\nAs noise is added to images, the early steps still reflect the original image’s structure. The model learns how these noisy images relate to their associated text descriptions via the text embeddings. That is, it learns different ways that an image of an orange cat tends to break down under noise compared to how an image of a brown dog breaks down. These differences are part of the “learned patterns” discussed earlier, and they help steer the model toward generating different images.\n\nWhen you later type a prompt like “an orange cat” or “a fantasy castle with a dragon,” that text is converted into a text embedding and fed into the model at every step of the denoising process. The text embedding gently steers each step of noise removal toward images that match your prompt. Again, the model does not know the previous stages; the best it can do is make predictions about what likely versions of those stages might have been. The information encoded in the text embedding for “an orange cat” helps guide those predictions toward something that looks like an orange cat rather than a brown dog.\n\n![Figure 2: An image from Google Gemini when prompted for a \"realistic orange cat,\" generated by Google Gemini (Nano Banana version), January 16, 2026.](realistic_orange_cat.png)\n\nThis process is not perfect, and models still make mistakes. However, by using diffusion models, we turn the hard problem of creating an image from nothing into the much easier task of removing a little noise at a time. In this way, diffusion models are able to generate remarkably accurate images from random static.\n\n# Conclusion\n\nTo summarize, diffusion models operate in two stages: a forward stage and a backward stage. In the forward stage, we turn an image into random static, while learning how these noisy images relate to their text descriptions via text embeddings. In the backward, or denoising, stage, we slowly move from static back toward an image, as text embeddings nudge the model’s predictions toward outputs that match the prompt. As these predictions improve, the generated images become increasingly accurate.\n\n# References: \n\n[1] 3Blue1Brown. (2025, July 25). But how do AI images and videos actually work? | Guest video by Welch Labs [Video]. YouTube. https://www.youtube.com/watch?v=iv-5mZ_9CPY\n\n[2] Ho, J., Jain, A., & Abbeel, P. (2020). Denoising diffusion probabilistic models. Advances in Neural Information Processing Systems, 33, 6840–6851. https://proceedings.neurips.cc/paper/2020/file/4c5bcfec8584af0d967f1ab10179ca4b-Paper.pdf\n","srcMarkdownNoYaml":"\n\n\n\n# A simple explanation of image-generating AI models: Diffusion Models and the Game of Telephone\n\nWith the popularity and advancement of AI rapidly accelerating, artificial intelligence has become a part of daily life for many people. In particular, advances in image-generating AI models have been an especially exciting area. Diffusion models, named after the physical process they are inspired by, are currently the most widely used and successful tools for generating images with AI.\nDiffusion models are complex, but in this post I will attempt to break them down in a more manageable way to help explain how they work. At a high level, diffusion models can be divided into two stages: a forward stage and a backward stage. Surprisingly, these processes can be explained quite simply by likening them to a game of telephone.\n\n## Moving Forwards\n\nFor anyone who has never played, telephone starts when one person whispers a phrase or sentence into another person’s ear. That phrase is then passed to the next person, and the next, until it reaches the last person in line. The goal of the game is to keep the phrase as close to the original as possible. Inevitably, as the phrase moves down the line, people make mistakes and it gets morphed into something completely different, often nonsensical. This is what makes the game enjoyable — you never really know what will happen at the end. For example, the phrase “a cat jumps over the moon and runs across the stars” might end up as “the cat’s stars are jumps and the moon is over.”\n\n![Figure 1: A game of telephone where carrot turns into elephant ducks and a bicycle. Generated by Google Gemini (Nano Banana version), January 16, 2026](telephone.png)\n\nA diffusion model works in a somewhat similar way. We start with an image and iteratively add random noise — small random changes to the pixels — until the image becomes pure static, like the static on a TV. This noise plays a role similar to the changes that happen as a phrase moves from person to person in the game of telephone. Each step makes the image a little stranger, until eventually it is no longer recognizable at all. Unlike in the game, however, these changes are not caused by misunderstanding; they are deliberately added randomness.\n\n\n\n## Learning to Go Backwards\n\nSo why would we want to destroy an image like this?\nLet’s return to our telephone analogy. Imagine playing a billion games of telephone, and for each game there is a single observer. This observer is not part of the game, but they can hear the phrase at every step as it moves down the line. Over time, they become very good at understanding the kinds of changes that typically happen from one step to the next. Eventually, they learn how to predict what the phrase likely sounded like before the most recent change.\n\n![Figure 2: Diffusion process.](diffusion.png)\n\nIf we now give this observer the final, altered phrase, they could work backwards step by step, predicting how to undo each change until they reach something very close to the original sentence. Importantly, the observer does not know the previous phrases. The best they can do is make incremental predictions about what likely versions of the earlier stages might have been. If they make good predictions, they may get close to the original phrase.\nThis is essentially how diffusion models work as well. During training, the model learns similar patterns — specifically, how to predict the noise that was added at each step of the process. Then, when generating an image, the model starts from pure noise and repeatedly removes small amounts of it. Step by step, random static turns into structure, and structure turns into an image.\n\nWhen you enter a prompt into an image generator — “an orange cat,” for example — the model begins with static and gradually works backwards, predicting how to remove noise a little bit at a time in a way that results in something resembling an orange cat. Just like the observer, the model doesn’t actually know the previous stages. It only sees the static. The best it can do is make predictions about what likely versions of those earlier stages might have been, based on its learned patterns and the description “an orange cat” (more on this later). This is why AI-generated images are sometimes not quite right: the model cannot always return to something that perfectly resembles an actual orange cat, just as the observer cannot always recover the original phrase.\n\n## Text Embeddings\nThat explanation raises another question: how does the model know how to make a cat when asked for a cat, and a dog when asked for a dog?\n\nThe answer lies in something called text embeddings.\n\nDuring training, each image is paired with a text description, such as an image of an orange cat labeled “an orange cat.”This text is converted into a text embedding — a numerical representation of the meaning of the description that can be passed to the model. The image and its text embedding are then processed together.\nAs noise is added to images, the early steps still reflect the original image’s structure. The model learns how these noisy images relate to their associated text descriptions via the text embeddings. That is, it learns different ways that an image of an orange cat tends to break down under noise compared to how an image of a brown dog breaks down. These differences are part of the “learned patterns” discussed earlier, and they help steer the model toward generating different images.\n\nWhen you later type a prompt like “an orange cat” or “a fantasy castle with a dragon,” that text is converted into a text embedding and fed into the model at every step of the denoising process. The text embedding gently steers each step of noise removal toward images that match your prompt. Again, the model does not know the previous stages; the best it can do is make predictions about what likely versions of those stages might have been. The information encoded in the text embedding for “an orange cat” helps guide those predictions toward something that looks like an orange cat rather than a brown dog.\n\n![Figure 2: An image from Google Gemini when prompted for a \"realistic orange cat,\" generated by Google Gemini (Nano Banana version), January 16, 2026.](realistic_orange_cat.png)\n\nThis process is not perfect, and models still make mistakes. However, by using diffusion models, we turn the hard problem of creating an image from nothing into the much easier task of removing a little noise at a time. In this way, diffusion models are able to generate remarkably accurate images from random static.\n\n# Conclusion\n\nTo summarize, diffusion models operate in two stages: a forward stage and a backward stage. In the forward stage, we turn an image into random static, while learning how these noisy images relate to their text descriptions via text embeddings. In the backward, or denoising, stage, we slowly move from static back toward an image, as text embeddings nudge the model’s predictions toward outputs that match the prompt. As these predictions improve, the generated images become increasingly accurate.\n\n# References: \n\n[1] 3Blue1Brown. (2025, July 25). But how do AI images and videos actually work? | Guest video by Welch Labs [Video]. YouTube. https://www.youtube.com/watch?v=iv-5mZ_9CPY\n\n[2] Ho, J., Jain, A., & Abbeel, P. (2020). Denoising diffusion probabilistic models. Advances in Neural Information Processing Systems, 33, 6840–6851. https://proceedings.neurips.cc/paper/2020/file/4c5bcfec8584af0d967f1ab10179ca4b-Paper.pdf\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":["cosmo","brand"],"title-block-banner":true,"title":"How AI Generates Images: A Simple Explanation","author":"Devon Vorster","date":"2026-01-15","date-modified":"2026-01-15","categories":["news","code","analysis"],"image":"image.jpg"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}